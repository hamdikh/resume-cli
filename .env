package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

type ProjectTfvars struct {
	Prefix                       string            `json:"prefix"`
	Project                      string            `json:"project"`
	Environment                  string            `json:"environment"`
	Location                     string            `json:"location"`
	AksIlbSubnetAddressPrefix    string            `json:"aks_ilb_subnet_address_prefix"`
	AksClusterSubnetAddressPrefixes map[string]string `json:"aks_cluster_subnet_address_prefixes"`
}

type ClusterTfvars struct {
	Cluster struct {
		Type                    string `json:"type"`
		KubernetesVersion       string `json:"kubernetes_version"`
		AksAgentPoolVmsize      string `json:"aks_agent_pool_vmsize"`
		AksSubnetAddressPrefix  string `json:"aks_subnet_address_prefix,omitempty"`
	} `json:"cluster"`
}

func updateProjectTfvars(projectTfvarsPath string, clustersPath string) error {
	// Read and unmarshal project.tfvars.json
	projectTfvarsContent, err := ioutil.ReadFile(projectTfvarsPath)
	if err != nil {
		return fmt.Errorf("error reading project.tfvars.json: %v", err)
	}

	var projectTfvars ProjectTfvars
	err = json.Unmarshal(projectTfvarsContent, &projectTfvars)
	if err != nil {
		return fmt.Errorf("error unmarshalling project.tfvars.json: %v", err)
	}

	if projectTfvars.AksClusterSubnetAddressPrefixes == nil {
		projectTfvars.AksClusterSubnetAddressPrefixes = make(map[string]string)
	}

	// Traverse the clusters directory
	err = filepath.Walk(clustersPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Only process directories named blue, green, yellow, or purple
		if info.IsDir() && (info.Name() == "blue" || info.Name() == "green" || info.Name() == "yellow" || info.Name() == "purple") {
			clusterTfvarsPath := filepath.Join(path, "cluster.tfvars.json")
			if _, err := os.Stat(clusterTfvarsPath); err == nil {
				// Read and unmarshal cluster.tfvars.json
				clusterTfvarsContent, err := ioutil.ReadFile(clusterTfvarsPath)
				if err != nil {
					return fmt.Errorf("error reading cluster.tfvars.json: %v", err)
				}

				var clusterTfvars ClusterTfvars
				err = json.Unmarshal(clusterTfvarsContent, &clusterTfvars)
				if err != nil {
					return fmt.Errorf("error unmarshalling cluster.tfvars.json: %v", err)
				}

				// Extract cluster name and aks_subnet_address_prefix
				clusterName := filepath.Base(path)
				aksSubnetAddressPrefix := clusterTfvars.Cluster.AksSubnetAddressPrefix

				// Update project.tfvars.json
				projectTfvars.AksClusterSubnetAddressPrefixes[clusterName] = aksSubnetAddressPrefix

				// Remove aks_subnet_address_prefix from cluster.tfvars.json
				clusterTfvars.Cluster.AksSubnetAddressPrefix = ""

				// Marshal and write the updated cluster.tfvars.json
				updatedClusterTfvarsContent, err := json.MarshalIndent(clusterTfvars, "", "    ")
				if err != nil {
					return fmt.Errorf("error marshalling updated cluster.tfvars.json: %v", err)
				}

				err = ioutil.WriteFile(clusterTfvarsPath, updatedClusterTfvarsContent, 0644)
				if err != nil {
					return fmt.Errorf("error writing updated cluster.tfvars.json: %v", err)
				}
			}
		}

		return nil
	})

	if err != nil {
		return fmt.Errorf("error traversing clusters directory: %v", err)
	}

	// Marshal updated project.tfvars.json content
	updatedProjectTfvarsContent, err := json.MarshalIndent(projectTfvars, "", "    ")
	if err != nil {
		return fmt.Errorf("error marshalling updated project.tfvars.json: %v", err)
	}

	// Write back the updated project.tfvars.json
	err = ioutil.WriteFile(projectTfvarsPath, updatedProjectTfvarsContent, 0644)
	if err != nil {
		return fmt.Errorf("error writing updated project.tfvars.json: %v", err)
	}

	fmt.Println("Updated", projectTfvarsPath, "successfully")
	return nil
}

func main() {
	basePath := "region"
	environmentNames := []string{"bld", "dev", "int", "uat", "prd"}

	err := filepath.Walk(basePath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Process directories named with GUIDs
		if info.IsDir() && filepath.Base(path) != "region" {
			for _, env := range environmentNames {
				envPath := filepath.Join(path, env)
				if _, err := os.Stat(envPath); err == nil {
					err = filepath.Walk(envPath, func(path string, info os.FileInfo, err error) error {
						if err != nil {
							return err
						}

						// Process project directories
						if info.IsDir() && filepath.Base(path) != env {
							// Check for project.tfvars.json in the current directory
							projectTfvarsPath := filepath.Join(path, "project.tfvars.json")
							clustersPath := filepath.Join(path, "clusters")
							if _, err := os.Stat(projectTfvarsPath); err == nil {
								if _, err := os.Stat(clustersPath); err == nil {
									// Update the project.tfvars.json with cluster subnet prefixes
									if err := updateProjectTfvars(projectTfvarsPath, clustersPath); err != nil {
										fmt.Println("Error updating project.tfvars.json:", err)
									}
								}
							}
						}

						return nil
					})

					if err != nil {
						fmt.Println("Error traversing environment directory:", err)
					}
				}
			}
		}

		return nil
	})

	if err != nil {
		fmt.Println("Error traversing base directory:", err)
	}
}
