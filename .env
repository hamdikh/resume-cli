package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

type ProjectTfvars struct {
	Prefix                      string            `json:"prefix"`
	Project                     string            `json:"project"`
	Environment                 string            `json:"environment"`
	Location                    string            `json:"location"`
	AksIlbSubnetAddressPrefixes map[string]string `json:"aks_ilb_subnet_address_prefixes"`
}

type ClusterTfvars struct {
	Cluster struct {
		AksSubnetAddressPrefix string `json:"aks_subnet_address_prefix"`
	} `json:"cluster"`
}

func updateProjectTfvars(projectTfvarsPath string, clustersPath string) error {
	// Read and unmarshal project.tfvars.json
	projectTfvarsContent, err := ioutil.ReadFile(projectTfvarsPath)
	if err != nil {
		return fmt.Errorf("error reading project.tfvars.json: %v", err)
	}

	var projectTfvars ProjectTfvars
	err = json.Unmarshal(projectTfvarsContent, &projectTfvars)
	if err != nil {
		return fmt.Errorf("error unmarshalling project.tfvars.json: %v", err)
	}

	if projectTfvars.AksIlbSubnetAddressPrefixes == nil {
		projectTfvars.AksIlbSubnetAddressPrefixes = make(map[string]string)
	}

	// Traverse the clusters directory
	err = filepath.Walk(clustersPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() && info.Name() != "clusters" {
			clusterTfvarsPath := filepath.Join(path, "cluster.tfvars.json")
			if _, err := os.Stat(clusterTfvarsPath); err == nil {
				// Read and unmarshal cluster.tfvars.json
				clusterTfvarsContent, err := ioutil.ReadFile(clusterTfvarsPath)
				if err != nil {
					return fmt.Errorf("error reading cluster.tfvars.json: %v", err)
				}

				var clusterTfvars ClusterTfvars
				err = json.Unmarshal(clusterTfvarsContent, &clusterTfvars)
				if err != nil {
					return fmt.Errorf("error unmarshalling cluster.tfvars.json: %v", err)
				}

				// Extract cluster name and aks_subnet_address_prefix
				clusterName := filepath.Base(path)
				aksSubnetAddressPrefix := clusterTfvars.Cluster.AksSubnetAddressPrefix

				// Update project.tfvars.json
				projectTfvars.AksIlbSubnetAddressPrefixes[clusterName] = aksSubnetAddressPrefix
			}
		}

		return nil
	})

	if err != nil {
		return fmt.Errorf("error traversing clusters directory: %v", err)
	}

	// Marshal updated project.tfvars.json content
	updatedProjectTfvarsContent, err := json.MarshalIndent(projectTfvars, "", "    ")
	if err != nil {
		return fmt.Errorf("error marshalling updated project.tfvars.json: %v", err)
	}

	// Write back the updated project.tfvars.json
	err = ioutil.WriteFile(projectTfvarsPath, updatedProjectTfvarsContent, 0644)
	if err != nil {
		return fmt.Errorf("error writing updated project.tfvars.json: %v", err)
	}

	fmt.Println("Updated", projectTfvarsPath, "successfully")
	return nil
}

func main() {
	basePath := "subscription"

	// Traverse the base directory for subscriptions
	err := filepath.Walk(basePath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() && filepath.Base(path) != "subscription" {
			// Check for project.tfvars.json in the current directory
			projectTfvarsPath := filepath.Join(path, "project.tfvars.json")
			clustersPath := filepath.Join(path, "clusters")
			if _, err := os.Stat(projectTfvarsPath); err == nil {
				if _, err := os.Stat(clustersPath); err == nil {
					// Update the project.tfvars.json with cluster subnet prefixes
					if err := updateProjectTfvars(projectTfvarsPath, clustersPath); err != nil {
						fmt.Println("Error updating project.tfvars.json:", err)
					}
				}
			}
		}

		return nil
	})

	if err != nil {
		fmt.Println("Error traversing base directory:", err)
	}
}
