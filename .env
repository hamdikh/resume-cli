package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

func main() {
	baseDir := "." // Base directory containing subscriptions

	err := filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Check if the path is a cluster directory
		if info.IsDir() && isClusterDir(info.Name()) {
			projectDir := filepath.Dir(filepath.Dir(path))
			projectFile := filepath.Join(projectDir, "project.tfvars.json")
			clusterFile := filepath.Join(path, "cluster.tfvars.json")

			processCluster(projectFile, clusterFile, filepath.Base(path))
		}

		return nil
	})

	if err != nil {
		fmt.Printf("Error walking the path %q: %v\n", baseDir, err)
		return
	}
}

func isClusterDir(name string) bool {
	return name == "blue" || name == "green"
}

func processCluster(projectFile, clusterFile, clusterName string) {
	projectData, err := ioutil.ReadFile(projectFile)
	if err != nil {
		fmt.Printf("Error reading project file: %v\n", err)
		return
	}

	clusterData, err := ioutil.ReadFile(clusterFile)
	if err != nil {
		fmt.Printf("Error reading cluster file: %v\n", err)
		return
	}

	var projectConfig map[string]interface{}
	var clusterConfig map[string]interface{}

	err = json.Unmarshal(projectData, &projectConfig)
	if err != nil {
		fmt.Printf("Error unmarshaling project data: %v\n", err)
		return
	}

	err = json.Unmarshal(clusterData, &clusterConfig)
	if err != nil {
		fmt.Printf("Error unmarshaling cluster data: %v\n", err)
		return
	}

	cluster, ok := clusterConfig["cluster"].(map[string]interface{})
	if !ok {
		fmt.Printf("Error: 'cluster' key not found or not a map in %s\n", clusterFile)
		return
	}

	if projectConfig["aks_cluster_subnet_address_prefixes"] == nil {
		projectConfig["aks_cluster_subnet_address_prefixes"] = make(map[string]interface{})
	}

	aksClusterSubnets, ok := projectConfig["aks_cluster_subnet_address_prefixes"].(map[string]interface{})
	if !ok {
		fmt.Printf("Error: 'aks_cluster_subnet_address_prefixes' is not a map in %s\n", projectFile)
		return
	}

	if aksSubnet, ok := cluster["aks_subnet_address_prefix"].(string); ok {
		aksClusterSubnets[clusterName] = aksSubnet
		delete(cluster, "aks_subnet_address_prefix")
	}

	projectData, err = json.MarshalIndent(projectConfig, "", "    ")
	if err != nil {
		fmt.Printf("Error marshaling project data: %v\n", err)
		return
	}

	clusterData, err = json.MarshalIndent(clusterConfig, "", "    ")
	if err != nil {
		fmt.Printf("Error marshaling cluster data: %v\n", err)
		return
	}

	err = ioutil.WriteFile(projectFile, projectData, 0644)
	if err != nil {
		fmt.Printf("Error writing project file: %v\n", err)
		return
	}

	err = ioutil.WriteFile(clusterFile, clusterData, 0644)
	if err != nil {
		fmt.Printf("Error writing cluster file: %v\n", err)
		return
	}

	fmt.Printf("Processed %s for project %s\n", clusterName, projectFile)
}
